name: Deploy to Linux Server

on:
  push:
    branches: [ master, dev ]
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force complete rebuild'
        required: false
        default: 'false'
        type: boolean

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Set environment based on branch
      run: |
        if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
          echo "ENVIRONMENT=prod" >> $GITHUB_ENV
          echo "DEPLOY_PATH=/root/mowebsite" >> $GITHUB_ENV
          echo "IMAGE_TAG=prod" >> $GITHUB_ENV
        else
          echo "ENVIRONMENT=dev" >> $GITHUB_ENV
          echo "DEPLOY_PATH=/root/mowebsite-dev" >> $GITHUB_ENV
          echo "IMAGE_TAG=dev" >> $GITHUB_ENV
        fi

    - name: Build and push container image
      uses: docker/build-push-action@v6
      with:
        context: ./src/Mo.PersonalWebsite
        file: ./src/Mo.PersonalWebsite/Dockerfile
        push: true
        provenance: false
        tags: |
          ghcr.io/${{ github.repository_owner }}/mo-personalwebsite:${{ env.IMAGE_TAG }}
          ghcr.io/${{ github.repository_owner }}/mo-personalwebsite:latest
        cache-from: type=registry,ref=ghcr.io/${{ github.repository_owner }}/mo-personalwebsite:buildcache
        cache-to: type=registry,ref=ghcr.io/${{ github.repository_owner }}/mo-personalwebsite:buildcache,mode=max

    - name: Ensure GHCR package is public (best effort)
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        set -e
        echo "Attempting to set GHCR package visibility to public (safe to ignore if already public)..."
        curl -s -L -X PATCH \
          -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer $GH_TOKEN" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          https://api.github.com/users/${{ github.repository_owner }}/packages/container/mo-personalwebsite/visibility \
          -d '{"visibility":"public"}' || true

    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts
        
        # Configure SSH to prevent timeouts
        cat >> ~/.ssh/config << EOF
        Host ${{ secrets.SERVER_HOST }}
          ServerAliveInterval 60
          ServerAliveCountMax 3
          TCPKeepAlive yes
        EOF

    - name: Deploy to server
      run: |
        # Copy only deployment folder to server
        rsync -avz --delete ./deployment/ ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }}:${{ env.DEPLOY_PATH }}/deployment/
        
        # SSH into server and deploy with optimized approach
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
          cd ${{ env.DEPLOY_PATH }}/deployment

          # Create environment file with secrets
          cat > .env.${{ env.ENVIRONMENT }} << EOL
        ENVIRONMENT=${{ env.ENVIRONMENT }}
        ASPNETCORE_ENVIRONMENT=${{ env.ENVIRONMENT == 'prod' && 'Production' || 'Development' }}
        WEBAPP_PORT=${{ secrets.WEBAPP_PORT || '3000' }}
        SQL_PORT=${{ env.ENVIRONMENT == 'prod' && '1433' || '1434' }}
        DATABASE_NAME=MoPersonalWebsite_${{ env.ENVIRONMENT == 'prod' && 'Prod' || 'Dev' }}
        SQL_SERVER_PASSWORD=${{ secrets.SQL_SERVER_PASSWORD }}
        ADMIN_USERNAME=${{ secrets.ADMIN_USERNAME }}
        ADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD }}
        LOG_LEVEL_DEFAULT=${{ env.ENVIRONMENT == 'prod' && 'Warning' || 'Information' }}
        LOG_LEVEL_ASPNETCORE=${{ env.ENVIRONMENT == 'prod' && 'Error' || 'Warning' }}
        IMAGE_TAG=${{ env.IMAGE_TAG }}
        WEBAPP_MEMORY_LIMIT=${{ env.ENVIRONMENT == 'prod' && '1G' || '512M' }}
        WEBAPP_MEMORY_RESERVATION=${{ env.ENVIRONMENT == 'prod' && '512M' || '256M' }}
        SQL_MEMORY_LIMIT=${{ env.ENVIRONMENT == 'prod' && '2G' || '1G' }}
        SQL_MEMORY_RESERVATION=${{ env.ENVIRONMENT == 'prod' && '1G' || '512M' }}
        EOL

          # Deploy with docker-compose (pull latest then up)
          docker-compose --env-file .env.${{ env.ENVIRONMENT }} pull webapp || true
          docker-compose --env-file .env.${{ env.ENVIRONMENT }} up -d --remove-orphans
          
          # Wait for services to be ready
          echo "Waiting for services to start..."
          sleep 30
          
          # Verify deployment
          echo "Verifying deployment..."
          docker-compose --env-file .env.${{ env.ENVIRONMENT }} ps
          
          # Check if webapp is responding
          WEBAPP_PORT=$(grep WEBAPP_PORT .env.${{ env.ENVIRONMENT }} | cut -d '=' -f2)
          echo "Testing webapp on port $WEBAPP_PORT..."
          timeout 30 curl -f http://localhost:$WEBAPP_PORT/ || echo "Warning: Webapp health check failed"
          
          # Verify static files are accessible
          echo "Verifying static files..."
          docker exec mo-website-${{ env.ENVIRONMENT }} ls -la /app/wwwroot/css/ || echo "Warning: CSS files not found"
          docker exec mo-website-${{ env.ENVIRONMENT }} ls -la /app/wwwroot/js/ || echo "Warning: JS files not found"
          
          # Clean up environment file for security
          rm -f .env.${{ env.ENVIRONMENT }}
        EOF